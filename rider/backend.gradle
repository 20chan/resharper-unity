def backendGroup = 'backend'

import org.apache.tools.ant.taskdefs.condition.Os

import java.util.regex.Matcher
import java.util.regex.Pattern

ext.isWindows = Os.isFamily(Os.FAMILY_WINDOWS)
ext.backend = new BackendHelper("..")
ext.extraMSBuildArgs = []

class BackendHelper {
    File repositoryRoot
    File unityRoot
    File backendRoot
    File solution
    File unityPluginSolution
    File riderTestsProject // used to build RiderOnly configurations

    BackendHelper(String repoRoot) {
        repositoryRoot = new File(repoRoot).canonicalFile
        assert repositoryRoot.isDirectory()

        backendRoot = new File(repositoryRoot, 'resharper')
        assert backendRoot.isDirectory()

        unityRoot = new File(repositoryRoot, 'unity')
        unityPluginSolution = new File(unityRoot, 'JetBrains.Rider.Unity.Editor/JetBrains.Rider.Unity.Editor.sln')

        solution = new File(backendRoot, 'src/resharper-unity.sln')
        assert solution.isFile()

        riderTestsProject = new File(backendRoot, 'test/src/tests.rider.csproj')
        assert riderTestsProject.isFile()
    }
}

class MSBuildTask extends DefaultTask {
    @InputFile
    def File buildFile

    // Set msbuild verbosity based on gradle log level

    @TaskAction
    def build() {
        project.ci.Progress("Building $buildFile ($project.BuildConfiguration)")

        def arguments = [ buildFile, "/p:Configuration=$project.BuildConfiguration", "/p:Version=$project.version", '/v:minimal', '/nologo'] //, "/bl:${buildFile.name}.binlog" ]
        arguments.addAll(project.extraMSBuildArgs)
        project.exec {
            executable = findMSBuildPath()
            args = arguments
        }
    }

    def findMSBuildPath() {
        if (project.ext.has('msbuildPath')) {
            logger.lifecycle("msbuildPath (cached): $project.msbuildPath")
            return project.msbuildPath
        }

        project.ext.msbuildPath = project.isWindows ? findMSBuildPathWindows() : findMSBuildPathUnix()
        logger.lifecycle "msbuildPath: $project.msbuildPath"
        return project.msbuildPath
    }

    def findMSBuildPathWindows() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = project.file(new File(project.backend.repositoryRoot, 'tools/vswhere.exe'))
            args = [ "-latest", "-products", "*", "-requires", "Microsoft.Component.MSBuild", "-property", "installationPath" ]
            standardOutput = stdout
        }

        def buildToolsDir = project.file(stdout.toString().trim())
        assert buildToolsDir.isDirectory()

        return project.file(new File(buildToolsDir, 'MSBuild/15.0/Bin/MSBuild.exe'))
    }

    def findMSBuildPathUnix() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = 'which'
            args = [ 'msbuild' ]
            standardOutput = stdout
        }

        return project.file(stdout.toString().trim())
    }
}

class MonoExecTask extends AbstractExecTask {
    MonoExecTask() {
        super(MonoExecTask.class)
    }

    @TaskAction
    protected void exec() {
        if (!project.isWindows) {
            def newCommandLine = [ 'mono' ]
            newCommandLine.addAll(commandLine)
            commandLine = newCommandLine
        }

        super.exec()
    }
}

class RestorePackagesTask extends DefaultTask {
    @InputFile
    def File packagesFile

    @TaskAction
    def restore() {
        if (project.SkipNuGetRestore) {
            logger.lifecycle('SkipNuGetRestore=true, skipping restore')
            return
        }

        project.ci.Progress("Restoring packages for $packagesFile")

        def restoreArguments = [ 'restore' ]
        if (project.PackageSource != null) {
            restoreArguments << '--source' << 'https://api.nuget.org/v3/index.json'
            restoreArguments << '--source' << 'https://www.myget.org/F/jetbrains-rider-sdk-snapshots/api/v3/index.json'
            restoreArguments << '--source' << project.PackageSource
        }
        restoreArguments.addAll project.extraMSBuildArgs
        restoreArguments << packagesFile
        project.exec {
            executable = 'dotnet'
            args = restoreArguments
        }
    }
}

task findLocalRiderSDKVersion {
    group backendGroup
    description 'Find version of local Rider SDK version'

    onlyIf { PackageSource != null }

    doLast {
        def directory = file(PackageSource)
        assert directory.isDirectory()

        def packageName = 'JetBrains.Rider.SDK'
        def escapedPackageName = Pattern.quote(packageName)

        logger.lifecycle("Looking for package $packageName in $directory")

        def packageVersion = directory.listFiles().collect { File f ->
            if (f.isFile()) {
                logger.trace(f.name)

                def match = (f.name =~ /^(?i)$escapedPackagedName\.((\d+\.)+\d+((-eap|-snapshot)\d+(d?)(pre|internal)?)?)\.nupkg\u0024/)
                if (math.matches()) {
                    return match[0][1]
                }
            }

            return null
        }.find { String s -> s != null }

        assert packageVersion != null : 'No files found matching the package version regex'

        extraMSBuildArgs << "/p:RiderSDKVersion=$packageVersion"
    }
}

task restoreUnityEditorPluginPackages(type: RestorePackagesTask) {
    group backendGroup
    description 'Restores packages for Unity Editor plugin'
    dependsOn findLocalRiderSDKVersion
    packagesFile backend.unityPluginSolution
}

task restoreBackendPluginPackages(type: RestorePackagesTask) {
    group backendGroup
    description 'Restores packages for backend plugin'
    dependsOn findLocalRiderSDKVersion
    packagesFile backend.solution
}

task buildUnityEditorPlugin(type: MSBuildTask) {
    dependsOn restoreUnityEditorPluginPackages
    group backendGroup
    description 'Builds Unity Editor plugin assemblies'
    buildFile = backend.unityPluginSolution
}

task buildBackendPlugin(type: MSBuildTask) {
    dependsOn restoreBackendPluginPackages, buildUnityEditorPlugin
    group backendGroup
    description 'Builds ReSharper plugin assemblies'
    buildFile = RiderOnly ? backend.riderTestsProject : backend.solution
}

task packReSharperPlugin(type: MonoExecTask) {
    dependsOn buildBackendPlugin
    group = backendGroup
    description = 'Packs resulting DLLs into a NuGet package which is an R# extension.'

    def nuspecFile = file(new File(backend.backendRoot, 'src/resharper-unity/resharper-unity.resharper.nuspec'))
    def outputDir = file(new File(backend.backendRoot, "build/resharper-unity.resharper/bin/$BuildConfiguration"))
    def nupkgFile = file(new File(outputDir, "JetBrains.Unity.${version}.nupkg"))

    // TODO: Make the output of the compile step the inputs of this step, as well as the nuspec
    // inputs.files(nuspecFile)
    outputs.files(nupkgFile)

    def nugetExe = file(new File(backend.repositoryRoot, 'tools/nuget.exe'))
    def arguments = [ 'pack', nuspecFile, '-NoPackageAnalysis', '-Properties', "Configuration=$BuildConfiguration", '-Version', "$version", '-OutputDirectory', outputDir ]

    executable = nugetExe
    args = arguments

    doFirst {
        ci.Progress("Packing: $nuspecFile.name")
    }
}

task publishBackendArtifacts {
    inputs.file(packReSharperPlugin.outputs)

    doLast {
        ci.PublishArtifact(packReSharperPlugin.outputs.files.singleFile)
    }
}

task buildBackend {
    dependsOn publishBackendArtifacts
    group = backendGroup
    description = 'Builds .NET part of the plugin.'

    doLast {
        ci.SetBuildNumber(version)
    }
}
