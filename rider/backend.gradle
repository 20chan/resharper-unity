def backendGroup = 'backend'


import java.util.regex.Pattern

ext.backend = new BackendHelper(ext.repoRoot, buildDir, logger, project, ext.productVersion)

class BackendHelper {
    File repositoryRoot
    File unityRoot
    File backendRoot
    File resharperHostPluginSolution
    File unityPluginSolution
    File unityPluginSingleProject   // For "rider only" configuration
    File riderTestsProject  // For "rider only" configuration
    File bundledReSharperSdkPath
    File downloadedReSharperSdkPath
    File bundledRiderSdkPath

    private Project project
    private String productVersion

    BackendHelper(File repoRoot, File buildDir, Logger logger, Project project, String productVersion) {
        repositoryRoot = repoRoot
        assert repositoryRoot.isDirectory()

        this.project = project
        this.productVersion = productVersion

        backendRoot = new File(repositoryRoot, 'resharper')
        assert backendRoot.isDirectory()

        unityRoot = new File(repositoryRoot, 'unity')
        unityPluginSolution = new File(unityRoot, 'JetBrains.Rider.Unity.Editor.sln')
        unityPluginSingleProject = new File(unityRoot, 'EditorPlugin/EditorPlugin.csproj')

        resharperHostPluginSolution = new File(backendRoot, 'src/resharper-unity.sln')
        assert resharperHostPluginSolution.isFile()

        riderTestsProject = new File(backendRoot, 'test/src/tests.rider.csproj')
        assert riderTestsProject.isFile()

        bundledRiderSdkPath = new File(repositoryRoot, "rider/dependencies")
        if (bundledRiderSdkPath.isDirectory()) {
            def riderSdkPath = new File(bundledRiderSdkPath.canonicalPath, "lib/ReSharperHostSdk")
            assert riderSdkPath.isDirectory()
            logger.lifecycle("Rider SDK bundle found: $riderSdkPath.canonicalPath")
        }

        bundledReSharperSdkPath = new File(repositoryRoot, "rider/build/JetBrains.ReSharperUltimate.Packages")
        if (bundledReSharperSdkPath.isDirectory()) {
            logger.lifecycle("ReSharper SDK bundle found: $bundledReSharperSdkPath.canonicalPath")
        }
    }

    def getRiderSdkPath() {
        if (bundledRiderSdkPath.isDirectory()) {
            return bundledRiderSdkPath
        }

        // TODO: This has common logic with getRdLibDirectory

        File root = new File(repositoryRoot, "rider/build/riderRD-$productVersion-SNAPSHOT")
        if (project.intellij.ideaDependencyCachePath != null) {
            root = new File(project.intellij.ideaDependencyCachePath)
        }
        if (root == null || !root.isDirectory()) {
            // If this assert fires, then you've likely called getRiderSdkPath during configuration
            // Try to wrap this call in a closure, so that it's evaluated at execution time, once the
            // intellij dependencies have been downloaded
            assert project.intellij.ideaDependency != null
            root = new File(project.intellij.ideaDependency.classes.absolutePath)
        }

        assert root != null

        def sdkRoot = new File(root, "lib/ReSharperHostSdk")
        assert sdkRoot.isDirectory()
        return sdkRoot
    }

    def getReSharperSdkPath() {
        if (bundledReSharperSdkPath.isDirectory()) {
            return bundledReSharperSdkPath
        }
        return downloadedReSharperSdkPath
    }
}

class MSBuildTask extends DefaultTask {
    @InputFile
    File buildFile

    @TaskAction
    def build() {
        project.ci.Progress("Building $buildFile ($project.BuildConfiguration)")

        def arguments = [ buildFile, "/p:Configuration=$project.BuildConfiguration", "/p:Version=$project.version", "/v:${getVerbosity()}", '/nologo'] //, "/bl:${buildFile.name}.binlog" ]

        def msbuildPath = findMSBuildPath()
        logger.info("msbuild call=$msbuildPath " + arguments.toString())

        project.exec {
            executable = msbuildPath
            args = arguments
            standardOutput = System.out
        }
    }

    def findMSBuildPath() {
        if (project.ext.has('msbuildPath')) {
            logger.info("msbuildPath (cached): $project.msbuildPath")
            return project.msbuildPath
        }

        project.ext.msbuildPath = project.isWindows ? findMSBuildPathWindows() : findMSBuildPathUnix()
        logger.info "msbuildPath: $project.msbuildPath"
        return project.msbuildPath
    }

    def findMSBuildPathWindows() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = project.file(new File(project.backend.repositoryRoot, 'tools/vswhere.exe'))
            args = [ "-latest", "-products", "*", "-requires", "Microsoft.Component.MSBuild", "-property", "installationPath" ]
            standardOutput = stdout
        }

        def buildToolsDir = project.file(stdout.toString().trim())
        assert buildToolsDir.isDirectory()

        return project.file(new File(buildToolsDir, 'MSBuild/15.0/Bin/MSBuild.exe'))
    }

    def findMSBuildPathUnix() {
        def stdout = new ByteArrayOutputStream()
        project.exec {
            executable = 'which'
            args = [ 'msbuild' ]
            standardOutput = stdout
        }

        return project.file(stdout.toString().trim())
    }

    def getVerbosity() {
        // TODO: Remove this when changing project build config to call gradle with --info
        if (project.ext.isBuildingUnderCi) {
            return "normal"
        }
        switch (project.gradle.startParameter.logLevel) {
            case LogLevel.QUIET:        return "quiet"
            case LogLevel.LIFECYCLE:    return "minimal"
            case LogLevel.INFO:         return "normal"
            case LogLevel.DEBUG:        return "detailed"
        }
        return "normal"
    }
}

class MonoExecTask extends AbstractExecTask {
    MonoExecTask() {
        super(MonoExecTask.class)
    }

    @TaskAction
    protected void exec() {
        if (!project.isWindows) {
            def newCommandLine = [ 'mono' ]
            newCommandLine.addAll(commandLine)
            commandLine = newCommandLine
        }

        super.exec()
    }
}

class GenerateBuildPropsTask extends DefaultTask {
    @Input
    def packagesDirectory
    String packageName
    String msBuildParameter

    @Input
    def Provider<String> packageVersion = project.providers.provider({ parsePackageVersion() })

    @OutputFile
    def Provider<File> propsFile = project.providers.provider({ new File("$project.repoRoot/resharper/${packageName}.generated.props") })

    @TaskAction
    def generate() {
        project.ci.Progress("Generating Build.props for $packageName")
        def version = packageVersion.get()
        logger.info("$msBuildParameter=$version")

        project.file(propsFile).text = """<Project>
  <PropertyGroup>
    <$msBuildParameter>[$version]</$msBuildParameter>    
  </PropertyGroup>
</Project>
"""
    }

    private String parsedPackageVersion = null
    def parsePackageVersion() {
        if (parsedPackageVersion != null) {
            return parsedPackageVersion
        }

        def packagesDir = project.file(packagesDirectory)
        assert packagesDir.isDirectory()
        def escapedPackageName = Pattern.quote(packageName)

        logger.info("Looking for package $packageName in $packagesDir")

        parsedPackageVersion = packagesDir.listFiles().collect { File f ->
            if (f.isFile()) {
                logger.trace(f.name)

                def match = (f.name =~ /^(?i)$escapedPackageName\.((\d+\.)+\d+((-eap|-snapshot)\d+(d?)(pre|internal)?)?)\.nupkg\u0024/)
                if (match.matches()) {
                    return match[0][1]
                }
            }

            return null
        }.find { String s -> s != null }

        assert packageVersion != null : 'No files found matching the package version regex'
        return packageVersion
    }
}


nuget {
    version = "4.4.1"
}

// Workaround for https://github.com/Ullink/gradle-nuget-plugin/issues/66
nugetSources {
    operation = 'add'
    sourceName = 'foo'
    sourceUrl = '/tmp'
}

// if there's no bundled SDK and we have to build R#, we download & unzip it, changing SDK path
task unzipReSharperSdk(type: Sync){
    group backendGroup
    onlyIf { !project.shouldBuildRiderOnly }    

    if (!backend.bundledReSharperSdkPath.isDirectory()) {
        dependsOn configurations.resharper
        def zipFile = configurations.resharper.singleFile

        // Unzip to the gradle cache folder, unless we're on Windows, where doing that hits the file path length limit
        if (isWindows) {
            backend.downloadedReSharperSdkPath = new File(repoRoot, "resharper/build/JetBrains.ReSharper.SDK")
        }
        else {
            backend.downloadedReSharperSdkPath = new File(zipFile.parentFile, "JetBrains.ReSharper.SDK")
        }

        from { configurations.resharper.collect { zipTree(it) } }
        into backend.downloadedReSharperSdkPath

        doFirst {
          ci.Progress("Unzipping ReSharper SDK to $backend.downloadedReSharperSdkPath")
        }
    }
}

task prepareRiderBuildProps(type: GenerateBuildPropsTask) {
    group backendGroup

    packagesDirectory { backend.getRiderSdkPath() }
    packageName "JetBrains.Rider.SDK"
    msBuildParameter "RiderSDKVersion"
}

task prepareReSharperBuildProps(type: GenerateBuildPropsTask) {
    group backendGroup
    dependsOn unzipReSharperSdk

    packagesDirectory { backend.getReSharperSdkPath() }
    packageName "JetBrains.ReSharper.SDK"
    msBuildParameter "ReSharperSDKVersion"
}

task prepareBuildProps {
    dependsOn prepareRiderBuildProps, prepareReSharperBuildProps
}

task prepareNuGetConfig {
    dependsOn unzipReSharperSdk

    doLast {
        def riderSdkPath = backend.getRiderSdkPath()
        def resharperSdkPath = backend.getReSharperSdkPath()

        assert riderSdkPath.isDirectory()
        assert resharperSdkPath.isDirectory()

        ci.Progress("Preparing NuGet.Config")

        def nugetConfigText = """<?xml version="1.0" encoding="utf-8"?>
    <configuration>
    <packageSources>
        <add key="local-rider-sdk" value="$riderSdkPath" />
        <add key="local-resharper-sdk" value="$resharperSdkPath" />
    </packageSources>
    </configuration>
    """
        logger.info(nugetConfigText)
        new File("$repoRoot/resharper/NuGet.Config").text = nugetConfigText
    }
}

task restoreUnityEditorPluginPackages(type: nugetRestore.class) {
    group backendGroup
    description 'Restores packages for Unity Editor plugin'

    solutionFile backend.unityPluginSolution
    sources = [
            'https://api.nuget.org/v3/index.json'
    ]
    doFirst {
        project.ci.Progress("Restoring packages for $solutionFile")

        // Add in doFirst, so we get a chance to download the SDKs
        sources.add(project.backend.getRiderSdkPath())
        sources.add(project.backend.getReSharperSdkPath())
    }
}

task restoreReSharperHostPluginPackages(type: nugetRestore.class) {
    group backendGroup
    description 'Restores packages for backend plugin'
    dependsOn prepareBuildProps, prepareNuGetConfig

    solutionFile backend.resharperHostPluginSolution
    sources = [
            'https://api.nuget.org/v3/index.json'
    ]
    doFirst {
        project.ci.Progress("Restoring packages for $solutionFile")

        // Add in doFirst, so we get a chance to download the SDKs
        sources.add(project.backend.getRiderSdkPath())
        sources.add(project.backend.getReSharperSdkPath())
    }
}


task buildFullReSharperPlugin(type: MSBuildTask) {
    group restoreReSharperHostPluginPackages
    description 'Builds the fill ReSharper backend plugin solution'
    dependsOn restoreReSharperHostPluginPackages

    onlyIf { !project.shouldBuildRiderOnly }

    buildFile = backend.resharperHostPluginSolution
}

task buildRiderOnlyPlugin(type: MSBuildTask) {
    group backendGroup
    description 'Builds the Rider plugin project'
    dependsOn restoreReSharperHostPluginPackages

    onlyIf { project.shouldBuildRiderOnly }

    buildFile = backend.riderTestsProject
}

task buildUnityEditorPluginFull(type: MSBuildTask) {
    group backendGroup
    description 'Builds full Unity editor plugin solution'
    dependsOn restoreUnityEditorPluginPackages

    onlyIf { !project.shouldBuildRiderOnly }

    buildFile = backend.unityPluginSolution
}

task buildUnityEditorPluginLight(type: MSBuildTask) {
    group backendGroup
    description 'Builds the Unity editor plugin project'
    dependsOn restoreUnityEditorPluginPackages

    onlyIf { project.shouldBuildRiderOnly }

    buildFile = backend.unityPluginSingleProject
}


task buildReSharperHostPlugin {
    group = backendGroup
    description = 'Build the ReSharper plugin for Rider and/or ReSharper'

    // We need to have two dependencies here. We want to change behaviour based on
    // which root level task we're executing, and we only know that at execution time.
    // The `buildPlugin` and `runIde` tasks will set the `shouldBuildRiderOnly` flag,
    // but only at execution time, not at configuration time. So we don't know what we're
    // building until we start building.
    // So, set up two tasks that are really only different in what project or solution
    // they build, and skip one of them at execution time by checking `shouldBuildRiderOnly`.
    // I can't think of a nicer way to have `prepareSandbox` depend on different tasks
    // based on what's executing
    dependsOn buildRiderOnlyPlugin, buildFullReSharperPlugin
}

nunit {
    onlyIf { !project.shouldBuildRiderOnly }
    dependsOn buildFullReSharperPlugin
    nunitVersion "2.6.4"
    framework "net-4.6.1"
    shadowCopy false
    outputs.upToDateWhen { false } // we should always run unit tests when RunTests are true

    def buildDir = new File(backend.repositoryRoot, "resharper/build")
    def riderTestsDll = new File(buildDir, "tests.rider/bin/$BuildConfiguration/net461/JetBrains.ReSharper.Plugins.Unity.Tests.Rider.dll")
    def resharperTestsDll = new File(buildDir, "tests.resharper/bin/$BuildConfiguration/net461/JetBrains.ReSharper.Plugins.Unity.Tests.ReSharper.dll")    
    testAssemblies = [riderTestsDll, resharperTestsDll]
}

task buildUnityEditorPlugin {
    group = backendGroup
    description = 'Build the Unity editor plugin'

    // See comment above
    dependsOn buildUnityEditorPluginLight, buildUnityEditorPluginFull
}

task packReSharperPlugin(type: MonoExecTask) {
    dependsOn buildReSharperHostPlugin
    group = backendGroup
    description = 'Packs resulting DLLs into a NuGet package which is an R# extension.'

    def nuspecFile = file(new File(backend.backendRoot, 'src/resharper-unity/resharper-unity.resharper.nuspec'))
    def outputDir = file(new File(backend.backendRoot, "build/resharper-unity.resharper/bin/$BuildConfiguration"))
    def nupkgFile = file(new File(outputDir, "JetBrains.Unity.${version}.nupkg"))

    // TODO: Make the output of the compile step the inputs of this step, as well as the nuspec
    // inputs.files(nuspecFile)
    outputs.files(nupkgFile)

    def nugetExe = file(new File(backend.repositoryRoot, 'tools/nuget.exe'))
    def arguments = [ 'pack', nuspecFile, '-NoPackageAnalysis', '-Properties', "Configuration=$BuildConfiguration", '-Version', "$version", '-OutputDirectory', outputDir ]

    executable = nugetExe
    args = arguments

    doFirst {
        ci.Progress("Packing: $nuspecFile.name")
    }
}

// This doesn't work right now. See https://github.com/Ullink/gradle-nuget-plugin/pull/69
//task packReSharperPlugin(type: nugetPack.class) {
//    dependsOn buildReSharperHostPlugin
//    group = backendGroup
//    description = 'Packs resulting DLLs into a NuGet package which is an R# extension.'
//
//    nuspecFile = new File(backend.backendRoot, 'src/resharper-unity/resharper-unity.resharper.nuspec')
//    destinationDir = new File(backend.backendRoot, "build/resharper-unity.resharper/bin/$BuildConfiguration")
//    packageAnalysis = false
//    packageVersion = version
//    properties = [
//            'Configuration': BuildConfiguration
//    ]
//
//    doFirst {
//        ci.Progress("Packing: $nuspecFile.name")
//    }
//}

task publishCiBackendArtifacts {
    inputs.file(packReSharperPlugin.outputs)

    doLast {
        ci.PublishArtifact(packReSharperPlugin.outputs.files.singleFile)
    }
}
publishCiBuildData.dependsOn publishCiBackendArtifacts
