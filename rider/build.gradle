import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
    ext.rd_version = '0.183.47'

    repositories {
        maven { url "https://cache-redirector.jetbrains.com/myget.org.rd-snapshots.maven" }
        maven { url "https://cache-redirector.jetbrains.com/maven-central" }
    }

    dependencies {
        classpath "com.jetbrains.rd:rd-gen:${rd_version}"
    }
}

plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.3-M2'
    id 'org.jetbrains.intellij' version '0.3.2'
    id 'com.ullink.nunit' version '1.12' 
}


apply plugin: 'com.jetbrains.rdgen'
apply from: 'ci.gradle'


ext.RdGen = com.jetbrains.rider.generator.gradle.RdgenTask
ext.productVersion = "2018.3"
ext.repoRoot = new File("..").canonicalFile
ext.isWindows = Os.isFamily(Os.FAMILY_WINDOWS)
ext.localRiderSdkRoot = new File("dependencies")  // SDK from TC configuration/artifacts
ext.rdLibDirectory = getRdLibDirectory()  // Note that this is also used by the protocol project
ext.shouldBuildRiderOnly = false

if (!ext.has("BuildCounter"))
    ext.BuildCounter = 9999

if (!ext.has("BuildConfiguration")) {
    ext.BuildConfiguration = ext.isBuildingUnderCi ? "Release" : "Debug"
}

if (!ext.has('dotNetUpToDate') || ext.dotNetUpToDate ==~ "(?i)False")
    ext.dotNetUpToDate = false

/* done as an optional step so that we can reuse the build artifacts */
if (!ext.has("RunTests") || ext.RunTests ==~ "(?i)False")
    ext.RunTests = false



configurations {
    reSharper
}

repositories {
    maven { url "https://cache-redirector.jetbrains.com/intellij-repository/snapshots" }
    maven { url "https://cache-redirector.jetbrains.com/maven-central" }
    maven { url "https://cache-redirector.jetbrains.com/dl.bintray.com/kotlin/kotlin-eap" }
}

dependencies {
    reSharper group: "com.jetbrains.intellij.resharper", name: "resharperUltimatePackages", version: "${productVersion}-SNAPSHOT", ext: "zip"
}

wrapper {
    gradleVersion = '4.7'
    distributionUrl = "https://cache-redirector.jetbrains.com/services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
}

version "${productVersion}.0.$BuildCounter"


logger.lifecycle("version=$version")
logger.lifecycle("Configuration=$BuildConfiguration")


apply from: 'backend.gradle'
apply from: 'frontend.gradle'
apply from: 'model.gradle'


// Tasks:
//
// When running in CI, we call `gradle buildPlugin`
// When running interactively, we call `gradle runIde`
// We can pass `-PdotNetUpToDate=true` to skip building dotnet things, as the no-op build is REALLY slow
//
// `buildPlugin` depends on `prepareSandbox` and then zips up the sandbox dir and puts the file in rider/build/distributions
// `runIde` depends on `prepareSandbox` and then executes IJ inside the sandbox dir
// `prepareSandbox` depends on the standard Java `jar` task and then copies everything into the sandbox dir
//
// `buildPlugin`, `runIde` and `prepareSandbox` are provided by the intellij gradle plugin
//
// When running in CI, the CI tasks will publish build version and the ReSharper artifacts
// When calling `buildPlugin`, the CI tasks force building the ReSharper artifacts
// When calling `runIde`, we only need to build Rider, debugger and Unity editor bits


task resolveDependencies {
  description 'Resolves all projects dependencies from the repository'
  group 'Build Server'

  doLast {
    rootProject.allprojects { project ->
      project.buildscript.configurations.forEach { configuration ->
        if (configuration.canBeResolved) {
          configuration.resolve()
        }
      }

      project.configurations.forEach { configuration ->
        if (configuration.canBeResolved) {
          configuration.resolve()
        }
      }
    }
  }
}


def getRdLibDirectory() {
  def root = localRiderSdkRoot
  if (root.exists() && root.isDirectory()) {
    logger.lifecycle("'dependencies' dir found, using as Rider SDK root")
  }
  else {
    root = new File(repoRoot, "rider/build/riderRD-${productVersion}-SNAPSHOT")
  }
  return new File(root, "lib/rd").canonicalFile
}
