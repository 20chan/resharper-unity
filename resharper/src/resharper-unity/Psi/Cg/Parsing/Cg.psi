options
{
// Parser options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Gen";
  parserClassName="CgParserGenerated";
// Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
// FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Parsing.ParserMessages";
// Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/Cg";
// Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;
// Composite node type/element generation options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Tree.ICgTreeNode";
// Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Parsing.TokenNodeTypes";
  tokenTypeClassName="CgTokenNodeTypes";
// Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
// tokenTypeBaseIndex=2000;
// Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Tree";
  psiInterfacesTargetSubdir="Psi/Cg/Tree";
// Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Tree.Impl";
  psiStubsBaseClass="CgCompositeElement";
  psiStubsTargetSubdir="Psi/Cg/Tree/Impl";
// Existing composite node type base class
  elementTypeBaseClass="CgCompositeNodeType";
// Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Tree";
// Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="CG_";
// Namespace and suffix for custom element instance implementation created by
// node type when `customImpl` option is specfied.
// Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Unity.Psi.Cg.Tree.Impl";
  "customImplSuffix"="";
// Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;
// Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}

errorhandling cgFile
options
{
  stubBase="CgFileElement";
}
  :
    declaration*    
  ;

interface declaration
  :       
      structDeclaration
      | 
      (
        !(#type:typeName)
        !(#name:identifier)
        (
          globalVariableDeclaration[type, name]
          | functionDeclaration[type, name]
        )
      )
  ;

identifier
  :
    IDENTIFIER<CG_NAME, NameToken>
  ;
/*
  float foo : COLOR = 0;
*/
globalVariableDeclaration[typeName type, identifier name]
  :
    &type
    &name<CG_NAME, NameNode>
    (
      COLON
      semantic
    )?
    globalVariableInitializer?
    SEMICOLON
  ;

semantic // e.g. TEXCOORD, COLOR
  :
    identifier // TODO: keyword list, after that different keywords for vertex/pixel shaders 
  ;

globalVariableInitializer
  :
    EQUALS
    constantValue
  ;

constantValue
  :
    NUMERIC_LITERAL
    | FALSE_KEYWORD
    | TRUE_KEYWORD
  ;

typeName
  :
    builtInType
    | typeReference
  ;

builtInType
  :
    BOOL_KEYWORD
    | INT_KEYWORD
    | UINT_KEYWORD
    | DWORD_KEYWORD
    | HALF_KEYWORD
    | FLOAT_KEYWORD
    | DOUBLE_KEYWORD
    | VOID_KEYWORD // TODO: fix void variables
  ;

typeReference
  :
    identifier<CG_NAME, NameNode>
  ;

/* 
  struct foo {
    float field;
  };
*/
structDeclaration
  :
    STRUCT_KEYWORD
    identifier<CG_NAME, NameNode>
    LBRACE
    structFieldList
    RBRACE
    SEMICOLON
  ;

structFieldList
  :
    fieldDeclaration*
  ;

fieldDeclaration
  :
    typeName
    identifier<CG_NAME, NameNode>
    (
      COLON
      semantic      
    )?
    SEMICOLON
  ;

/* void foo(arg1, arg2){
    ...
   }
*/

functionDeclaration[typeName type, identifier name]
  :  
    VOID_KEYWORD    
    | &type
    &name<CG_NAME, NameNode>
    LPAREN
    functionArgList
    RPAREN
    LBRACE
    functionBody
    RBRACE
  ;

functionArgList
  :
    (
      argument
      (
        COMMA
        argument
      )*
    )?
  ;

argument
  :    
    typeName
    identifier<CG_NAME, NameNode>
  ;

functionBody
  :
    // TODO: remove IDENTIFIER match when all is done
    (
      localVariableDeclaration
      | IDENTIFIER* 
    )*
  ;

localVariableDeclaration
  :
    typeName
    identifier<CG_NAME, NameNode>
    (
      EQUALS
      expression
    )?
    SEMICOLON
  ;

// TODO: extend
expression 
  :
    constantValue
    | valueReference
  ;

valueReference
  :
    identifier<CG_NAME, NameNode>
  ;