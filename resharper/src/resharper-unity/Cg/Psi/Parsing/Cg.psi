options
{
// Parser options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Gen";
  parserClassName="CgParserGenerated";
// Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
// FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Parsing.ParserMessages";
// Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/Cg";
// Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;
// Composite node type/element generation options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.ICgTreeNode";
// Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Parsing.TokenNodeTypes";
  tokenTypeClassName="CgTokenNodeTypes";
// Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
// tokenTypeBaseIndex=2000;
// Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree";
  psiInterfacesTargetSubdir="Psi/Cg/Tree";
// Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.Impl";
  psiStubsBaseClass="CgCompositeElement";
  psiStubsTargetSubdir="Psi/Cg/Tree/Impl";
// Existing composite node type base class
  elementTypeBaseClass="CgCompositeNodeType";
// Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree";
// Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="CG_";
// Namespace and suffix for custom element instance implementation created by
// node type when `customImpl` option is specfied.
// Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.Impl";
  "customImplSuffix"="";
// Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;
// Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}

abstract errorElement
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
  :
    IDENTIFIER?
    | LBRACE
    | RBRACE
    | LPAREN
    | RPAREN
    | LBRACKET
    | RBRACKET
    | COMMA
    | SEMICOLON
    | COLON

    | QUESTION_MARK
    
    | LT
    | GT
    | LTEQ
    | GTEQ
    | EQEQ
    | NOTEQ

    | EQUALS

    | PLUS
    | MINUS
    | MULTIPLY
    | DIVIDE
    | MODULO

    | MULTEQ
    | DIVEQ
    | PERCEQ
    | PLUSEQ
    | MINUSEQ

    | TILDE
    | LTLT
    | GTGT
    | XOR
    | OR
    | AND
    | ANDAND
    | OROR
    | NEGATE

    | LTLTEQ
    | GTGTEQ
    | ANDEQ
    | XOREQ
    | OREQ

    | PLUSPLUS
    | MINUSMINUS

    | FALSE_KEYWORD
    | TRUE_KEYWORD
    
    | STRUCT_KEYWORD

    | RETURN_KEYWORD

    | IF_KEYWORD
    | ELSE_KEYWORD
    
    | DO_KEYWORD
    | WHILE_KEYWORD
    | FOR_KEYWORD

    | INLINE_KEYWORD
    | CONST_KEYWORD
    | STATIC_KEYWORD

    | IN_KEYWORD
    | INOUT_KEYWORD
    | OUT_KEYWORD
    | UNIFORM_KEYWORD

    | DIRECTIVE
    | DIRECTIVE_CONTENT

    | BOOL_KEYWORD
    | INT_KEYWORD
    | UINT_KEYWORD    
    | HALF_KEYWORD
    | FLOAT_KEYWORD
    | DOUBLE_KEYWORD // gives error on d3d11: vs_4_0 does not support doubles as a storage type at line 34 (on d3d11)

    | VOID_KEYWORD

    // vector
    | BOOL1_KEYWORD
    | BOOL2_KEYWORD
    | BOOL3_KEYWORD
    | BOOL4_KEYWORD
    
    | INT1_KEYWORD
    | INT2_KEYWORD
    | INT3_KEYWORD
    | INT4_KEYWORD
    
    | UINT1_KEYWORD
    | UINT2_KEYWORD
    | UINT3_KEYWORD
    | UINT4_KEYWORD
    
    | HALF1_KEYWORD
    | HALF2_KEYWORD
    | HALF3_KEYWORD
    | HALF4_KEYWORD
    
    | FLOAT1_KEYWORD
    | FLOAT2_KEYWORD
    | FLOAT3_KEYWORD
    | FLOAT4_KEYWORD
    
    | DOUBLE1_KEYWORD
    | DOUBLE2_KEYWORD
    | DOUBLE3_KEYWORD
    | DOUBLE4_KEYWORD

    // matrix
    // bool
    | BOOL1X1_KEYWORD
    | BOOL1X2_KEYWORD
    | BOOL1X3_KEYWORD
    | BOOL1X4_KEYWORD

    | BOOL2X1_KEYWORD
    | BOOL2X2_KEYWORD
    | BOOL2X3_KEYWORD
    | BOOL2X4_KEYWORD
    
    | BOOL3X1_KEYWORD
    | BOOL3X2_KEYWORD
    | BOOL3X3_KEYWORD
    | BOOL3X4_KEYWORD
    
    | BOOL4X1_KEYWORD
    | BOOL4X2_KEYWORD
    | BOOL4X3_KEYWORD
    | BOOL4X4_KEYWORD
    
    // int
    | INT1X1_KEYWORD
    | INT1X2_KEYWORD
    | INT1X3_KEYWORD
    | INT1X4_KEYWORD
    
    | INT2X1_KEYWORD
    | INT2X2_KEYWORD
    | INT2X3_KEYWORD
    | INT2X4_KEYWORD
    
    | INT3X1_KEYWORD
    | INT3X2_KEYWORD
    | INT3X3_KEYWORD
    | INT3X4_KEYWORD
    
    | INT4X1_KEYWORD
    | INT4X2_KEYWORD
    | INT4X3_KEYWORD
    | INT4X4_KEYWORD
    
    // uint
    | UINT1X1_KEYWORD
    | UINT1X2_KEYWORD
    | UINT1X3_KEYWORD
    | UINT1X4_KEYWORD
    
    | UINT2X1_KEYWORD
    | UINT2X2_KEYWORD
    | UINT2X3_KEYWORD
    | UINT2X4_KEYWORD
    
    | UINT3X1_KEYWORD
    | UINT3X2_KEYWORD
    | UINT3X3_KEYWORD
    | UINT3X4_KEYWORD
    
    | UINT4X1_KEYWORD
    | UINT4X2_KEYWORD
    | UINT4X3_KEYWORD
    | UINT4X4_KEYWORD
    
    // half
    | HALF1X1_KEYWORD
    | HALF1X2_KEYWORD
    | HALF1X3_KEYWORD
    | HALF1X4_KEYWORD
    
    | HALF2X1_KEYWORD
    | HALF2X2_KEYWORD
    | HALF2X3_KEYWORD
    | HALF2X4_KEYWORD
    
    | HALF3X1_KEYWORD
    | HALF3X2_KEYWORD
    | HALF3X3_KEYWORD
    | HALF3X4_KEYWORD
    
    | HALF4X1_KEYWORD
    | HALF4X2_KEYWORD
    | HALF4X3_KEYWORD
    | HALF4X4_KEYWORD
    
    // float
    | FLOAT1X1_KEYWORD
    | FLOAT1X2_KEYWORD
    | FLOAT1X3_KEYWORD
    | FLOAT1X4_KEYWORD
    
    | FLOAT2X1_KEYWORD
    | FLOAT2X2_KEYWORD
    | FLOAT2X3_KEYWORD
    | FLOAT2X4_KEYWORD
    
    | FLOAT3X1_KEYWORD
    | FLOAT3X2_KEYWORD
    | FLOAT3X3_KEYWORD
    | FLOAT3X4_KEYWORD
    
    | FLOAT4X1_KEYWORD
    | FLOAT4X2_KEYWORD
    | FLOAT4X3_KEYWORD
    | FLOAT4X4_KEYWORD
    
    // double
    | DOUBLE1X1_KEYWORD
    | DOUBLE1X2_KEYWORD
    | DOUBLE1X3_KEYWORD
    | DOUBLE1X4_KEYWORD
    
    | DOUBLE2X1_KEYWORD
    | DOUBLE2X2_KEYWORD
    | DOUBLE2X3_KEYWORD
    | DOUBLE2X4_KEYWORD
    
    | DOUBLE3X1_KEYWORD
    | DOUBLE3X2_KEYWORD
    | DOUBLE3X3_KEYWORD
    | DOUBLE3X4_KEYWORD
    
    | DOUBLE4X1_KEYWORD
    | DOUBLE4X2_KEYWORD
    | DOUBLE4X3_KEYWORD
    | DOUBLE4X4_KEYWORD
  ;

errorhandling cgFile
options
{
  stubBase="CgFileElement";
}
  :    
    (
      declaration
    )*
  ;

errorhandling directiveForceFollows
:
  directive
  (errorElement | WHITESPACE | NEW_LINE)
;

errorhandling directive
  :    
    DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>?
  ;

errorhandling declaration
  :       
      structDeclaration
      | 
      (
        !(#modifiers:modifierKeywordList)?
        !(#type:typeName)
        (
          macroCall[type]
          | variableOrFunctionDeclaration[modifiers, type]
        )
      )
  ;

variableOrFunctionDeclaration[modifierKeywordList modifiers, typeName type]
  :
    !(#name:identifier)
    (          
      (
       variableDeclaration[modifiers, type, name]
       SEMICOLON
      )
      | functionDeclaration[modifiers, type, name]
    )
  ;

// TODO: hack, macro call (e.g. CBUFFER_START(x), or CBUFFER_END)
// or UNITY_DECLARE_SHADOWMAP(_ShadowMapTexture); <- has the semicolon
macroCall[typeName type]
  :
    &type
    callOperator?
    SEMICOLON?
  ;

// TODO: split into var and function keywords?
modifierKeywordList
  : 
    (
      INLINE_KEYWORD
      | CONST_KEYWORD
      | STATIC_KEYWORD
      | UNIFORM_KEYWORD
      | IN_KEYWORD
      | OUT_KEYWORD
      | INOUT_KEYWORD
    )+
  ;

/* 
  struct foo {
    float field;
  };
*/
structDeclaration
  :
    STRUCT_KEYWORD
    identifier<CG_NAME, NameNode>
    LBRACE
    structFieldList
    RBRACE
    SEMICOLON
  ;

identifier
  :
    IDENTIFIER<CG_NAME, NameToken>
  ;

structFieldList
  :
    (
      fieldDeclaration
    )*
  ;

// TODO: hack for macros (e.g. UNITY_VERTEX_INPUT_INSTANCE_ID)
errorhandling fieldDeclaration
  :
    !(#modifiers:modifierKeywordList)?
    !(#type:typeName)
    (
      (
        !(#name:identifier)
        variableDeclaration<CG_CONTENT, ContentNode>[modifiers, type, name]
        SEMICOLON
      )
      | macroCall[type]
    )
  ;

// TODO: buffer types
// tex2D<float>
interface typeName
  :
    builtInType
    | typeReference
  ;

builtInType
  :
    BOOL_KEYWORD
    | INT_KEYWORD
    | UINT_KEYWORD    
    | HALF_KEYWORD
    | FLOAT_KEYWORD
    | DOUBLE_KEYWORD
    | VOID_KEYWORD
    // vector
    | BOOL1_KEYWORD
    | BOOL2_KEYWORD
    | BOOL3_KEYWORD
    | BOOL4_KEYWORD
    
    | INT1_KEYWORD
    | INT2_KEYWORD
    | INT3_KEYWORD
    | INT4_KEYWORD
    
    | UINT1_KEYWORD
    | UINT2_KEYWORD
    | UINT3_KEYWORD
    | UINT4_KEYWORD
    
    | HALF1_KEYWORD
    | HALF2_KEYWORD
    | HALF3_KEYWORD
    | HALF4_KEYWORD
    
    | FLOAT1_KEYWORD
    | FLOAT2_KEYWORD
    | FLOAT3_KEYWORD
    | FLOAT4_KEYWORD
    
    | DOUBLE1_KEYWORD
    | DOUBLE2_KEYWORD
    | DOUBLE3_KEYWORD
    | DOUBLE4_KEYWORD

    // matrix
    // bool
    | BOOL1X1_KEYWORD
    | BOOL1X2_KEYWORD
    | BOOL1X3_KEYWORD
    | BOOL1X4_KEYWORD

    | BOOL2X1_KEYWORD
    | BOOL2X2_KEYWORD
    | BOOL2X3_KEYWORD
    | BOOL2X4_KEYWORD
    
    | BOOL3X1_KEYWORD
    | BOOL3X2_KEYWORD
    | BOOL3X3_KEYWORD
    | BOOL3X4_KEYWORD
    
    | BOOL4X1_KEYWORD
    | BOOL4X2_KEYWORD
    | BOOL4X3_KEYWORD
    | BOOL4X4_KEYWORD
    
    // int
    | INT1X1_KEYWORD
    | INT1X2_KEYWORD
    | INT1X3_KEYWORD
    | INT1X4_KEYWORD
    
    | INT2X1_KEYWORD
    | INT2X2_KEYWORD
    | INT2X3_KEYWORD
    | INT2X4_KEYWORD
    
    | INT3X1_KEYWORD
    | INT3X2_KEYWORD
    | INT3X3_KEYWORD
    | INT3X4_KEYWORD
    
    | INT4X1_KEYWORD
    | INT4X2_KEYWORD
    | INT4X3_KEYWORD
    | INT4X4_KEYWORD
    
    // uint
    | UINT1X1_KEYWORD
    | UINT1X2_KEYWORD
    | UINT1X3_KEYWORD
    | UINT1X4_KEYWORD
    
    | UINT2X1_KEYWORD
    | UINT2X2_KEYWORD
    | UINT2X3_KEYWORD
    | UINT2X4_KEYWORD
    
    | UINT3X1_KEYWORD
    | UINT3X2_KEYWORD
    | UINT3X3_KEYWORD
    | UINT3X4_KEYWORD
    
    | UINT4X1_KEYWORD
    | UINT4X2_KEYWORD
    | UINT4X3_KEYWORD
    | UINT4X4_KEYWORD
    
    // half
    | HALF1X1_KEYWORD
    | HALF1X2_KEYWORD
    | HALF1X3_KEYWORD
    | HALF1X4_KEYWORD
    
    | HALF2X1_KEYWORD
    | HALF2X2_KEYWORD
    | HALF2X3_KEYWORD
    | HALF2X4_KEYWORD
    
    | HALF3X1_KEYWORD
    | HALF3X2_KEYWORD
    | HALF3X3_KEYWORD
    | HALF3X4_KEYWORD
    
    | HALF4X1_KEYWORD
    | HALF4X2_KEYWORD
    | HALF4X3_KEYWORD
    | HALF4X4_KEYWORD
    
    // float
    | FLOAT1X1_KEYWORD
    | FLOAT1X2_KEYWORD
    | FLOAT1X3_KEYWORD
    | FLOAT1X4_KEYWORD
    
    | FLOAT2X1_KEYWORD
    | FLOAT2X2_KEYWORD
    | FLOAT2X3_KEYWORD
    | FLOAT2X4_KEYWORD
    
    | FLOAT3X1_KEYWORD
    | FLOAT3X2_KEYWORD
    | FLOAT3X3_KEYWORD
    | FLOAT3X4_KEYWORD
    
    | FLOAT4X1_KEYWORD
    | FLOAT4X2_KEYWORD
    | FLOAT4X3_KEYWORD
    | FLOAT4X4_KEYWORD
    
    // double
    | DOUBLE1X1_KEYWORD
    | DOUBLE1X2_KEYWORD
    | DOUBLE1X3_KEYWORD
    | DOUBLE1X4_KEYWORD
    
    | DOUBLE2X1_KEYWORD
    | DOUBLE2X2_KEYWORD
    | DOUBLE2X3_KEYWORD
    | DOUBLE2X4_KEYWORD
    
    | DOUBLE3X1_KEYWORD
    | DOUBLE3X2_KEYWORD
    | DOUBLE3X3_KEYWORD
    | DOUBLE3X4_KEYWORD
    
    | DOUBLE4X1_KEYWORD
    | DOUBLE4X2_KEYWORD
    | DOUBLE4X3_KEYWORD
    | DOUBLE4X4_KEYWORD
  ;

interface typeReference
  :
    identifier
  ;

semantic // e.g. TEXCOORD, COLOR
  :
    identifier // TODO: keyword list, after that different keywords for vertex/pixel shaders 
  ;


errorhandling singleVariableDeclaration[modifierKeywordList modifiers, typeName type, identifier name]
  :
    &modifiers?
    &type<CG_TYPE, TypeNode>
    &name<CG_NAME, NameNodes>
    variableDeclarationTail
  ;

// TODO: check if it's possible do semantics and arrays work when using comma to separate variable names
errorhandling variableDeclaration[modifierKeywordList modifiers, typeName type, identifier name]
  :
    singleVariableDeclaration<CG_CONTENT, FirstVariableNode>[modifiers, type, name]
    (
      COMMA
      identifier<CG_NAME, NameNodes>
      variableDeclarationTail
    )*
  ;

variableDeclarationTail
  :
    arrayOperator?
    (
      COLON
      semantic
    )?
    (
      EQUALS
      expression
    )?
  ;

// TODO: custom parse function to unwrap all this stuff
// TODO: proper precedence
errorhandling expression
  :
    assignmentExpression
  ;

assignmentExpression
  :
    ternaryExpression
    (
      assignmentOperator
      ternaryExpression      
    )*
  ;

assignmentOperator
  :
    EQUALS
    | MULTEQ
    | DIVEQ
    | PLUSEQ
    | MINUSEQ
    | PERCEQ

    | LTLTEQ
    | GTGTEQ
    | ANDEQ
    | XOREQ
    | OREQ
  ;

ternaryExpression
  :
    binaryExpression
    (
      QUESTION_MARK
      ternaryExpression
      COLON
      ternaryExpression
    )*
  ;

binaryExpression
  :
    prefixExpression
    (
      binaryOperator? // TODO: hack for casting, fix with proper parsing
      binaryExpression
    )*
  ;

binaryOperator
  :
    LT
    | GT
    | LTEQ
    | GTEQ
    | EQEQ
    | NOTEQ

    | PLUS
    | MINUS
    | MULTIPLY
    | DIVIDE
    | MODULO

    | TILDE
    | LTLT
    | GTGT
    | XOR
    | OR
    | AND
    | ANDAND
    | OROR
  ;

// TODO: cast operator
// (float)
prefixExpression
  :
    postfixExpression
    | 
    (
      prefixOperator
      prefixExpression
    )*
  ;

prefixOperator
  :
    NEGATE
    | TILDE
    | PLUS
    | MINUS
    | PLUSPLUS
    | MINUSMINUS
  ;

postfixExpression
  :
    primaryExpression<CG_OPERAND, OperandNode>
    (
      postfixOperator<CG_OPERATOR, OperatorNode>
    )*
  ;

interface postfixOperator
  :
    incrementOperator
    | decrementOperator
    | arrayOperator
    | callOperator
    | fieldOperator
  ;

incrementOperator
  :
    PLUSPLUS
  ;

decrementOperator
  :
    MINUSMINUS
  ;

arrayOperator
  :
    LBRACKET expression RBRACKET
  ;

callOperator
  :
    LPAREN
    (
      expression
      (
        COMMA
        expression
      )*
    )?
    RPAREN
  ;

fieldOperator
  :
    DOT
    identifier<CG_OPERAND, FieldNode>
  ;

interface primaryExpression
  :
    constantValue
    | runtimeValue
    | parensExpression
  ;

interface runtimeValue
  :
    builtInType // TODO: constructor call, e.g. float4(1,2,3,4)
    | identifier // TODO: may be variable reference or function name
    | vectorInitExpression
    | matrixInitExpression
  ;

vectorInitExpression
  :
    LBRACE
    (
      expression
      (
        COMMA
        expression
      )*
    )
    RBRACE
  ;

matrixInitExpression
  :
    LBRACE
      vectorInitExpression
      (
        COMMA
        vectorInitExpression
      )*
    RBRACE
  ;

parensExpression
  :
    LPAREN
    expression
    RPAREN
  ;

constantValue
  :
    NUMERIC_LITERAL
    | FALSE_KEYWORD
    | TRUE_KEYWORD
  ;

/* void foo(arg1, arg2){
    ...
   }
*/

// function can have semantics
// fixed4 frag (v2f i, UNITY_VPOS_TYPE screenPos : VPOS) : SV_Target
//
// function can have specifiers (TODO: look up proper name in docs)
functionDeclaration[modifierKeywordList modifiers, typeName type, identifier name]
  :
    functionHeader<CG_CONTENT, HeaderNode>[modifiers, type, name]
    functionBody
  ;

errorhandling functionHeader[modifierKeywordList modifiers, typeName type, identifier name]
  :
    &modifiers?
    &type<CG_TYPE, TypeNode>
    &name<CG_NAME, NameNode>
    LPAREN
    functionArgList?    
    RPAREN
    (
      COLON
      semantic
    )?
  ;

functionArgList
  :    
    argument
    (
      COMMA
      argument
    )*    
  ;

// argument can have semantics
// UNITY_VPOS_TYPE x : VPOS
// argument can have input modifier
// uniform int x
// argument can have initial value
// bool x = false
argument
  :
    !(#modifiers:modifierKeywordList)?
    !(#type:typeName)
    !(#name:identifier)
    singleVariableDeclaration<CG_CONTENT, VariableNode>[modifiers, type, name]
  ;

// TODO: allow nested non-flow controlling blocks if they are allowed
functionBody
  :
    LBRACE  
    (
      cgBlock
      | flowControlStatement
    )*
    RBRACE
  ;

errorhandling cgBlock
  :  
    !(#modifiers:modifierKeywordList)?
    (
      (
        !(#type:typeName)
        (
          (
            variableDeclarationStatement[modifiers, type]
            SEMICOLON
          )
          | 
          (
            expressionStatement[type]
            SEMICOLON?  // TODO: hack (PP macro call e.g. UNITY_BRANCH)
          )
        )
      ) | SEMICOLON
    )
  ;

interface flowControlStatement
  :
    ifStatement
    | forStatement
    | returnStatement
  ;

ifStatement
  :
    IF_KEYWORD
    LPAREN
    expression
    RPAREN
    (
      functionBody
      | cgBlock
    )
    elseStatement?
  ;

elseStatement
  :
    ELSE_KEYWORD
    (
      functionBody
      | cgBlock
      | ifStatement
    )
  ;

forStatement
  :
    forStatementHeader
    (
      functionBody
      | cgBlock
      | flowControlStatement
    )
  ;

errorhandling forStatementHeader // TODO: check spec
  :
    FOR_KEYWORD
    LPAREN
    cgBlock
    expression?
    SEMICOLON
    expression?
    RPAREN
  ;

variableDeclarationStatement[modifierKeywordList modifiers, typeName type]
  :
    !(#name:identifier)
    variableDeclaration[modifiers, type, name]
  ;

expressionStatement[typeName type]
  :
    &type // typeName is an interface for an identifier
    ( 
      fieldOperator
      | arrayOperator
      | callOperator
    )*
    (
      assignmentOperator
      ternaryExpression
    )*
  ;

returnStatement
  :
    RETURN_KEYWORD
    expression?
    SEMICOLON
  ;