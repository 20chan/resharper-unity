options
{
// Parser options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Gen";
  parserClassName="CgParserGenerated";
// Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
// FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Parsing.ParserMessages";
// Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/Cg";
// Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;
// Composite node type/element generation options
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.ICgTreeNode";
// Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Parsing.TokenNodeTypes";
  tokenTypeClassName="CgTokenNodeTypes";
// Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
// tokenTypeBaseIndex=2000;
// Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree";
  psiInterfacesTargetSubdir="Psi/Cg/Tree";
// Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.Impl";
  psiStubsBaseClass="CgCompositeElement";
  psiStubsTargetSubdir="Psi/Cg/Tree/Impl";
// Existing composite node type base class
  elementTypeBaseClass="CgCompositeNodeType";
// Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree";
// Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="CG_";
// Namespace and suffix for custom element instance implementation created by
// node type when `customImpl` option is specfied.
// Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Unity.Cg.Psi.Tree.Impl";
  "customImplSuffix"="";
// Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;
// Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}

abstract errorElement
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
  :
    IDENTIFIER?
    | LBRACE
    | RBRACE
    | LPAREN
    | RPAREN
    | COMMA
    | SEMICOLON
    | COLON
    
    | LT
    | GT
    | LTEQ
    | GTEQ
    | EQEQ
    | NOTEQ

    | EQUALS

    | PLUS
    | MINUS
    | MULTIPLY
    | DIVIDE
    | MODULO

    | MULTEQ
    | DIVEQ
    | PERCEQ
    | PLUSEQ
    | MINUSEQ

    | TILDE
    | LTLT
    | XOR
    | OR
    | ANDAND
    | OROR
    | NEGATE

    | LTLTEQ
    | GTGTEQ
    | ANDEQ
    | XOREQ
    | OREQ

    | PLUSPLUS
    | MINUSMINUS

    | FALSE_KEYWORD
    | TRUE_KEYWORD
    
    | STRUCT_KEYWORD

    | RETURN_KEYWORD

    | IF_KEYWORD
    | ELSE_KEYWORD
    
    | DO_KEYWORD
    | WHILE_KEYWORD
    | FOR_KEYWORD

    | IN_KEYWORD
    | INOUT_KEYWORD
    | OUT_KEYWORD
    | UNIFORM_KEYWORD

    | BOOL_KEYWORD
    | INT_KEYWORD
    | UINT_KEYWORD    
    | HALF_KEYWORD
    | FLOAT_KEYWORD
    | DOUBLE_KEYWORD // gives error on d3d11: vs_4_0 does not support doubles as a storage type at line 34 (on d3d11)

    | VOID_KEYWORD

    // vector
    | BOOL1_KEYWORD
    | BOOL2_KEYWORD
    | BOOL3_KEYWORD
    | BOOL4_KEYWORD
    
    | INT1_KEYWORD
    | INT2_KEYWORD
    | INT3_KEYWORD
    | INT4_KEYWORD
    
    | UINT1_KEYWORD
    | UINT2_KEYWORD
    | UINT3_KEYWORD
    | UINT4_KEYWORD
    
    | HALF1_KEYWORD
    | HALF2_KEYWORD
    | HALF3_KEYWORD
    | HALF4_KEYWORD
    
    | FLOAT1_KEYWORD
    | FLOAT2_KEYWORD
    | FLOAT3_KEYWORD
    | FLOAT4_KEYWORD
    
    | DOUBLE1_KEYWORD
    | DOUBLE2_KEYWORD
    | DOUBLE3_KEYWORD
    | DOUBLE4_KEYWORD

    // matrix
    // bool
    | BOOL1X1_KEYWORD
    | BOOL1X2_KEYWORD
    | BOOL1X3_KEYWORD
    | BOOL1X4_KEYWORD

    | BOOL2X1_KEYWORD
    | BOOL2X2_KEYWORD
    | BOOL2X3_KEYWORD
    | BOOL2X4_KEYWORD
    
    | BOOL3X1_KEYWORD
    | BOOL3X2_KEYWORD
    | BOOL3X3_KEYWORD
    | BOOL3X4_KEYWORD
    
    | BOOL4X1_KEYWORD
    | BOOL4X2_KEYWORD
    | BOOL4X3_KEYWORD
    | BOOL4X4_KEYWORD
    
    // int
    | INT1X1_KEYWORD
    | INT1X2_KEYWORD
    | INT1X3_KEYWORD
    | INT1X4_KEYWORD
    
    | INT2X1_KEYWORD
    | INT2X2_KEYWORD
    | INT2X3_KEYWORD
    | INT2X4_KEYWORD
    
    | INT3X1_KEYWORD
    | INT3X2_KEYWORD
    | INT3X3_KEYWORD
    | INT3X4_KEYWORD
    
    | INT4X1_KEYWORD
    | INT4X2_KEYWORD
    | INT4X3_KEYWORD
    | INT4X4_KEYWORD
    
    // uint
    | UINT1X1_KEYWORD
    | UINT1X2_KEYWORD
    | UINT1X3_KEYWORD
    | UINT1X4_KEYWORD
    
    | UINT2X1_KEYWORD
    | UINT2X2_KEYWORD
    | UINT2X3_KEYWORD
    | UINT2X4_KEYWORD
    
    | UINT3X1_KEYWORD
    | UINT3X2_KEYWORD
    | UINT3X3_KEYWORD
    | UINT3X4_KEYWORD
    
    | UINT4X1_KEYWORD
    | UINT4X2_KEYWORD
    | UINT4X3_KEYWORD
    | UINT4X4_KEYWORD
    
    // half
    | HALF1X1_KEYWORD
    | HALF1X2_KEYWORD
    | HALF1X3_KEYWORD
    | HALF1X4_KEYWORD
    
    | HALF2X1_KEYWORD
    | HALF2X2_KEYWORD
    | HALF2X3_KEYWORD
    | HALF2X4_KEYWORD
    
    | HALF3X1_KEYWORD
    | HALF3X2_KEYWORD
    | HALF3X3_KEYWORD
    | HALF3X4_KEYWORD
    
    | HALF4X1_KEYWORD
    | HALF4X2_KEYWORD
    | HALF4X3_KEYWORD
    | HALF4X4_KEYWORD
    
    // float
    | FLOAT1X1_KEYWORD
    | FLOAT1X2_KEYWORD
    | FLOAT1X3_KEYWORD
    | FLOAT1X4_KEYWORD
    
    | FLOAT2X1_KEYWORD
    | FLOAT2X2_KEYWORD
    | FLOAT2X3_KEYWORD
    | FLOAT2X4_KEYWORD
    
    | FLOAT3X1_KEYWORD
    | FLOAT3X2_KEYWORD
    | FLOAT3X3_KEYWORD
    | FLOAT3X4_KEYWORD
    
    | FLOAT4X1_KEYWORD
    | FLOAT4X2_KEYWORD
    | FLOAT4X3_KEYWORD
    | FLOAT4X4_KEYWORD
    
    // double
    | DOUBLE1X1_KEYWORD
    | DOUBLE1X2_KEYWORD
    | DOUBLE1X3_KEYWORD
    | DOUBLE1X4_KEYWORD
    
    | DOUBLE2X1_KEYWORD
    | DOUBLE2X2_KEYWORD
    | DOUBLE2X3_KEYWORD
    | DOUBLE2X4_KEYWORD
    
    | DOUBLE3X1_KEYWORD
    | DOUBLE3X2_KEYWORD
    | DOUBLE3X3_KEYWORD
    | DOUBLE3X4_KEYWORD
    
    | DOUBLE4X1_KEYWORD
    | DOUBLE4X2_KEYWORD
    | DOUBLE4X3_KEYWORD
    | DOUBLE4X4_KEYWORD
  ;

errorhandling cgFile
options
{
  stubBase="CgFileElement";
}
  :    
    (
      declaration
      | directive
    )*
  ;

errorhandling interface directive
  :
    conditionalDirective
    | nonConditionalDirective
  ;

conditionalDirective
  :    
    (
      IF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
      | IFDEF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
      | IFNDEF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    )
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
    directiveInternalContent
    (
      endifDirective
      | elseDirective
      | elifDirective
    )
  ;

directiveInternalContent
  :
    (
      declaration
      | directive
    )*
  ;

interface conditionalDirectiveFooter
  :
    elseDirective
    | endifDirective
    | elifDirective
  ;

elseDirective
  :
    ELSE_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
    directiveInternalContent
    endifDirective
  ;

elifDirective
  :
    ELIF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
    directiveInternalContent
    (
      endifDirective
      | elseDirective
      | elifDirective
    )
  ;

endifDirective
  :    
    ENDIF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

interface nonConditionalDirective
// options
// {
//   stubBase="CgNonConditionalDirectiveElement";
// }
  :
    includeDirective
    | defineDirective
    | undefDirective
    | lineDirective
    | errorDirective
    | warningDirective
    | pragmaDirective    
  ;

includeDirective
  :
    INCLUDE_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    INCLUDE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

defineDirective
  :
    DEFINE_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

undefDirective
  :
    UNDEF_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    CODE_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

lineDirective
  :
    LINE_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    META_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

errorDirective
  :
    ERROR_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    META_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

warningDirective
  :
    WARNING_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    META_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

pragmaDirective
  :
    PRAGMA_DIRECTIVE<CG_DIRECTIVE_HEADER, HeaderNode>
    META_DIRECTIVE_CONTENT<CG_DIRECTIVE_CONTENT, ContentNode>
  ;

errorhandling interface declaration
  :       
      structDeclaration
      | 
      (
        !(#type:typeName)
        !(#name:identifier)
        (
          globalVariableDeclaration[type, name]
          | functionDeclaration[type, name]
        )
      )
  ;

identifier
  :
    IDENTIFIER<CG_NAME, NameToken>
  ;
/*
  float foo : COLOR = 0;
*/
globalVariableDeclaration[typeName type, identifier name]
  :
    &type
    &name<CG_NAME, NameNode>
    (
      COLON
      semantic
    )?
    globalVariableInitializer?
    SEMICOLON
  ;

semantic // e.g. TEXCOORD, COLOR
  :
    identifier // TODO: keyword list, after that different keywords for vertex/pixel shaders 
  ;

globalVariableInitializer
  :
    EQUALS
    constantValue
  ;

constantValue
  :
    NUMERIC_LITERAL
    | FALSE_KEYWORD
    | TRUE_KEYWORD
  ;

typeName
  :
    builtInType
    | 
    (
      !(#userDeclaredType:identifier)
      typeReference[userDeclaredType]
    )
  ;

builtInType
  :
    BOOL_KEYWORD
    | INT_KEYWORD
    | UINT_KEYWORD    
    | HALF_KEYWORD
    | FLOAT_KEYWORD
    | DOUBLE_KEYWORD
    | VOID_KEYWORD
    // vector
    | BOOL1_KEYWORD
    | BOOL2_KEYWORD
    | BOOL3_KEYWORD
    | BOOL4_KEYWORD
    
    | INT1_KEYWORD
    | INT2_KEYWORD
    | INT3_KEYWORD
    | INT4_KEYWORD
    
    | UINT1_KEYWORD
    | UINT2_KEYWORD
    | UINT3_KEYWORD
    | UINT4_KEYWORD
    
    | HALF1_KEYWORD
    | HALF2_KEYWORD
    | HALF3_KEYWORD
    | HALF4_KEYWORD
    
    | FLOAT1_KEYWORD
    | FLOAT2_KEYWORD
    | FLOAT3_KEYWORD
    | FLOAT4_KEYWORD
    
    | DOUBLE1_KEYWORD
    | DOUBLE2_KEYWORD
    | DOUBLE3_KEYWORD
    | DOUBLE4_KEYWORD

    // matrix
    // bool
    | BOOL1X1_KEYWORD
    | BOOL1X2_KEYWORD
    | BOOL1X3_KEYWORD
    | BOOL1X4_KEYWORD

    | BOOL2X1_KEYWORD
    | BOOL2X2_KEYWORD
    | BOOL2X3_KEYWORD
    | BOOL2X4_KEYWORD
    
    | BOOL3X1_KEYWORD
    | BOOL3X2_KEYWORD
    | BOOL3X3_KEYWORD
    | BOOL3X4_KEYWORD
    
    | BOOL4X1_KEYWORD
    | BOOL4X2_KEYWORD
    | BOOL4X3_KEYWORD
    | BOOL4X4_KEYWORD
    
    // int
    | INT1X1_KEYWORD
    | INT1X2_KEYWORD
    | INT1X3_KEYWORD
    | INT1X4_KEYWORD
    
    | INT2X1_KEYWORD
    | INT2X2_KEYWORD
    | INT2X3_KEYWORD
    | INT2X4_KEYWORD
    
    | INT3X1_KEYWORD
    | INT3X2_KEYWORD
    | INT3X3_KEYWORD
    | INT3X4_KEYWORD
    
    | INT4X1_KEYWORD
    | INT4X2_KEYWORD
    | INT4X3_KEYWORD
    | INT4X4_KEYWORD
    
    // uint
    | UINT1X1_KEYWORD
    | UINT1X2_KEYWORD
    | UINT1X3_KEYWORD
    | UINT1X4_KEYWORD
    
    | UINT2X1_KEYWORD
    | UINT2X2_KEYWORD
    | UINT2X3_KEYWORD
    | UINT2X4_KEYWORD
    
    | UINT3X1_KEYWORD
    | UINT3X2_KEYWORD
    | UINT3X3_KEYWORD
    | UINT3X4_KEYWORD
    
    | UINT4X1_KEYWORD
    | UINT4X2_KEYWORD
    | UINT4X3_KEYWORD
    | UINT4X4_KEYWORD
    
    // half
    | HALF1X1_KEYWORD
    | HALF1X2_KEYWORD
    | HALF1X3_KEYWORD
    | HALF1X4_KEYWORD
    
    | HALF2X1_KEYWORD
    | HALF2X2_KEYWORD
    | HALF2X3_KEYWORD
    | HALF2X4_KEYWORD
    
    | HALF3X1_KEYWORD
    | HALF3X2_KEYWORD
    | HALF3X3_KEYWORD
    | HALF3X4_KEYWORD
    
    | HALF4X1_KEYWORD
    | HALF4X2_KEYWORD
    | HALF4X3_KEYWORD
    | HALF4X4_KEYWORD
    
    // float
    | FLOAT1X1_KEYWORD
    | FLOAT1X2_KEYWORD
    | FLOAT1X3_KEYWORD
    | FLOAT1X4_KEYWORD
    
    | FLOAT2X1_KEYWORD
    | FLOAT2X2_KEYWORD
    | FLOAT2X3_KEYWORD
    | FLOAT2X4_KEYWORD
    
    | FLOAT3X1_KEYWORD
    | FLOAT3X2_KEYWORD
    | FLOAT3X3_KEYWORD
    | FLOAT3X4_KEYWORD
    
    | FLOAT4X1_KEYWORD
    | FLOAT4X2_KEYWORD
    | FLOAT4X3_KEYWORD
    | FLOAT4X4_KEYWORD
    
    // double
    | DOUBLE1X1_KEYWORD
    | DOUBLE1X2_KEYWORD
    | DOUBLE1X3_KEYWORD
    | DOUBLE1X4_KEYWORD
    
    | DOUBLE2X1_KEYWORD
    | DOUBLE2X2_KEYWORD
    | DOUBLE2X3_KEYWORD
    | DOUBLE2X4_KEYWORD
    
    | DOUBLE3X1_KEYWORD
    | DOUBLE3X2_KEYWORD
    | DOUBLE3X3_KEYWORD
    | DOUBLE3X4_KEYWORD
    
    | DOUBLE4X1_KEYWORD
    | DOUBLE4X2_KEYWORD
    | DOUBLE4X3_KEYWORD
    | DOUBLE4X4_KEYWORD
  ;

typeReference[identifier userDeclaredType]
  :
    &userDeclaredType<CG_NAME, NameNode>    
  ;
  
/* 
  struct foo {
    float field;
  };
*/
structDeclaration
  :
    STRUCT_KEYWORD
    identifier<CG_NAME, NameNode>
    LBRACE
    structFieldList
    RBRACE
    SEMICOLON
  ;

structFieldList
  :
    fieldDeclaration*
  ;

fieldDeclaration
  :
    typeName
    identifier<CG_NAME, NameNode>
    (
      COLON
      semantic      
    )?
    SEMICOLON
  ;

/* void foo(arg1, arg2){
    ...
   }
*/

// function can have semantics
// fixed4 frag (v2f i, UNITY_VPOS_TYPE screenPos : VPOS) : SV_Target
functionDeclaration[typeName type, identifier name]
  :  
    VOID_KEYWORD    
    | &type
    &name<CG_NAME, NameNode>
    LPAREN
    functionArgList?    
    RPAREN
    (
      COLON
      semantic
    )?
    LBRACE
    functionBody
    RBRACE
  ;

functionArgList
  :    
    argument
    (
      COMMA
      argument
    )*    
  ;

// argument can have semantics
// UNITY_VPOS_TYPE x : VPOS
// argument can have input modifier
// uniform int x
argument
  :
    inputModifier?
    typeName
    identifier<CG_NAME, NameNode>
    (
      COLON
      semantic
    )?
  ;

inputModifier
  :
    IN_KEYWORD
    | INOUT_KEYWORD
    | OUT_KEYWORD
    | UNIFORM_KEYWORD
  ;

functionBody
  :
    cgBlock*
  ;

errorhandling cgBlock
  :      
    (
      (
        !(#id:identifier)
        (
          localVariableDeclaration[id]
          | assignment[id]
          | functionCall[id]
        )
      )
      | localVariableDeclaration[null]
      | returnStatement
    )
    SEMICOLON
  ;

localVariableDeclaration[identifier userDeclaredType]
  :
    (
      builtInType
      | typeReference[userDeclaredType]
    )    
    identifier<CG_NAME, NameNode>    
    (
      EQUALS
      expression
    )?    
  ;

// TODO: support assignment as f = a = 0 (check whether needed)
// TODO: precedence
errorhandling expression
  :
    unaryExpression
    (
      binaryOperator
      unaryExpression
    )*
  ;

unaryExpression
  :
    (
      unaryOperator
      unaryExpression
    )
    | primaryExpression    
  ;

unaryOperator
  :
    PLUS
    | MINUS
    | NEGATE
  ;

primaryExpression
  :
    constantValue
    | runtimeValue
    | parensExpression
  ;

// TODO: assignments
binaryOperator
  :
    LT
    | GT
    | LTEQ
    | GTEQ
    | EQEQ
    | NOTEQ

    | PLUS
    | MINUS
    | MULTIPLY
    | DIVIDE
    | MODULO

    | TILDE
    | LTLT
    | XOR
    | OR
    | ANDAND
    | OROR
  ;

runtimeValue
  :
    !(#id:identifier)
    (
      valueReference[id]
      | functionCall[id]
    )
  ;

valueReference[identifier variableName]
  :    
    variableReference[variableName]
    | fieldReference[variableName]
  ;

variableReference[identifier variableName]
  :
    &variableName
  ;

fieldReference[identifier variableName]
  :
    &variableName
    (
      DOT
      fieldName
    )+
  ;

fieldName
  :
    identifier
  ;

functionCall[identifier functionName]
  :
    &functionName<CG_NAME, NameNode>
    LPAREN
    functionCallArgList?
    RPAREN
  ;

functionCallArgList
  :
    expression
    (
      COMMA
      expression
    )*
  ;

assignment[identifier variableName]
  :
    valueReference[variableName]
    EQUALS
    expression  
  ;

returnStatement
  :
    RETURN_KEYWORD
    expression?
  ;

parensExpression
  :
    LPAREN
    expression
    RPAREN
  ;