options{

  // Parser options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Gen";
  parserClassName="ShaderLabParserGenerated";

  // Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";

  // FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Parsing.ParserMessages";

  // Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/ShaderLab";

  // Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;


  // Composite node type/element generation options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree.IShaderLabTreeNode";

  // Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Parsing";
  tokenTypeClassName="ShaderLabTokenType";

  // Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
  // tokenTypeBaseIndex=2000;

  // Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree";
  psiInterfacesTargetSubdir="Psi/ShaderLab/Tree";

  // Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree.Impl";
  psiStubsBaseClass="ShaderLabCompositeElement";
  psiStubsTargetSubdir="Psi/ShaderLab/Tree/Impl";

  // Existing composite node type base class
  elementTypeBaseClass="ShaderLabCompositeNodeType";

  // Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree";

  // Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="SHADER_LAB_";


  // Namespace and suffix for custom element instance implementation created by
  // node type when `customImpl` option is specfied.
  // Default suffix is `Impl`
  customImplPackage="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree.Impl";
  "customImplSuffix"="";


  // Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;

  // Required. If missing, generates Add/Remove methods for each collection
  generateWorkingPsi;
}



// Modifiers:
//
// `errorhandling` - includes following tokens in error handling. Checks next token is
//   valid following token. Generates virtual HandleErrorInXXX method that will skip to
//   the next valid following token. All tokens in between are added to the current error.
// `noerrorhandling` - same as omitting `errorhandling`
// `private` - the rule is effectively expanded inline, as part of the parent rule. Parent
//   rule references it with no role information
// `abstract` - does not create an element, interface or parse function.
// `interface` - defines a rule that can match one of multiple rules, all of which will have
//   a common base, e.g. `expression`, which can match `stringLiteralExpression`, `numericExpression`, etc.
//
// options:
//
// (not exhaustive)
// `customImpl` - the parser generates the element interface and a "stub" base implementation, but
//  generated node type will create an instance of a derived type that must be implemented manually.
//  The custom name ends with the `"customImplSuffix"` global option, and must be declared in the
//  `customImplPackage` namespace. It is named after the nonterminal, as usual. The generated base
//  element instance ends with the suffix `Stub`
// `customInterface` - generate element tree node with a custom interface. Name is the same
//   as would be generated, but uses `customInterfacePackage` for namespace
// `customParseFunction` - the parse function is abstract. The usually generated parse function is
//   also generated as a protected method with the suffix `Internal`
// `noInternalParseFunction` - stops the standard parse function being generated as parseXxxInernal
//   when `customParseFunction` is specified. If `customParseFunction` isn't specified, this creates
//   an error - a virtual method without an implementation.
// `parsingContext` - push a new parsing context. This sets a "global" token follows set for the
//   duration of the parsing context. Any nested nonterminals that implement `errorhandling` will
//   also check this follow set when skipping tokens after an error
// `stubBase="Foo"` - use `Foo` as the base class for the generated element instance. Overrides
//   `psiStubsBaseClass` global option
//
// Rules:
//
// (terminal|nonterminal) `customParseFunction? <ROLE, PropertyName>? Quantifier?
//
// * A new tree element is generated for each rule definition, with properties for each child rule
// * Rule starts with a terminal or a nonterminal token. If it's a terminal, it's a token from
//   the lexer (e.g. IDENTIFIER), otherwise, it's an identifier for another rule
// * An optional custom parse function comes next, preceded by a backtick. If specified, abstract
//   methods called matchXXX and expectXXX are generated and called. The implementation of matchXXX
//   should call expectXXX and return a TreeElement that represents what's been matched. The
//   expectXXX method should look at the current token and return true if it's what's expected
// * ROLE is the name of the child role generated. This can be a common role from the ChildRoles
//   class, or a name for a private role. If no role definition is given, the node isn't added to
//   the interface. A single property name can be used multiple times, in which case it is exposed
//   as either a collection, or the lowest common node type.
// * PropertyName is the name of the generated property to access this token
// * Quantifier can be ommitted, meaning nonoptional, optional (?), zero or more (*) or one or more (+)
//   Pipes and parentheses can also be used to separate and group rules
//
// !(#name:terminal|nonterminal) - e.g. !(#id:IDENTIFIER) or !(#id:shaderLabIdentifier)
//
// Captures the element into a named variable, to pass to another nonterminal. Parsing continues with the
// next matching token in the following rules. This allows switching on the second or third rule of multiple
// nonterminals that have a common prolog. E.g. two nonterminals starting with identifier but followed by
// DOT and COMMA respectively. The captured element is passed to the nonterminal with square brackets, e.g.
// qualifiedValue[id] and the parameter must be part of the nonterminal declaration, e.g. qualifiedValue[identifier id]
// where the first part is the token type and the second is the name. Multiple parameters can be sepcified,
// separated by commas. The captured element is used in the rules with an ampersand, and can have normal
// role definitions, e.g. &id or &id<IDENTIFIER, Identifier>. A rule may also pass null 



// The Tao of Error Handling
//
// * If a nonterminal fails to match the expected token, an exception is thrown
//   * The remaining rules and subsequent tokens are unmatched and unconsumed
// * The exception is rethrown by all parent nonterminals
//   * The current work in progress elements are attached as it goes
//   * Remaining rules and subsequent tokens are unmatched and unconsumed
// * The first nonterminal that implements errorhandling:
//   * Creates an error element from the exception text
//   * Adds it as a child to the current work in progress element
//   * Stops rethrowing
//   * All remaining rules are not parsed
//   * Skips tokens until one is in the valid follows set
// * If a nonterminal implements errorhandling and successfully matches all of its rules, it must also
//   be followed by a valid follow token, or an exception is thrown
// * If no nonterminals implement errorhandling, the error element is not added to the tree
// * If a nonterminal specifies a parsingContext option, it pushes a "global" follow set that any nested
//   errorhandling nonterminal will also use when skipping tokens
//   * Allows breaking the skip if there are no matching valid follows
//
// Custom error elements:
// * Create an abstract errorElement nonterminal
//   * It matches all tokens (make one optional so it also matches missing elements)
//   * Use this as a rule to match if correct rules have failed
//   * Options should include interfaceName="JB.RS.Psi.Tree.IErrorElement" and elementType="ERROR_ELEMENT"
//   * This will create an abstract parse method - implement with TreeElementFactory.CreateErrorElement
//     (no need to do any parsing - it's definitely an error)
// * Abstract means it has a custom parse method
//   * Implementation simply creates an error element and returns it
//   * Does not advance or consume children, etc.
//   * Means patterns in nonterminal definition are only useful as follow tokens
// * Can create similar elements
//   * Different set of tokens for different purposes, e.g. don't match closing braces
//   * Again, only useful for follow tokens
//   * Custom parse function can create error element, then skip all tokens until it finds a match,
//     based on whatever rules are required. Skipping will add token as child to error element
//
// Guidance:
//
// * The root nonterminal should implement errorhandling, or the error element will not get attached to anything
// * Split things up into smaller nested nonterminals that can be errorhandling
// * If a token or nonterminal is to be used as a resync point, the nonterminal directly
//   BEFORE it needs to implement errrorhandling
// * Or, resync AFTER a token, not on it. E.g. don't resync on a closing paren, only on
//   what follows a closing paren
// * A private nonterminal can help with errorhandling without generating a node for the tree
// * Use parsingContext when you have an errorhandling nested inside an errorhandling. The
//   parsinngContext adds new follow rules to the inner errorhandling follow set. ParsingContext
//   requires errorhandling somewhere, or no-one will ever check for the follow token override

// CSharp parser
//
// Argument list is set to error handling. Doesn't resync on closing paren, but on following token
// argumentListAux is LPAREN argumentList RPAREN, errorhandling
// argumentList is custom parse function. Of course. Handles leading comma, trailing comma,
//   cSharpArgument. Missing arguments (due to trailing/leading comma) are added as FakeArgument
// cSharpArgument is custom function (and error handling)
//   include ParseCSharpArgumentInternal + HandleErrorInCSharpArgument
//   ParseCSharpArgumentInternal doesn't get called. Custom function calls error handler


// Matches all tokens, but doesn't advance!
abstract errorElement
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
:
  IDENTIFIER?

  | CG_PROGRAM
  | CG_INCLUDE
  | CG_END

  | LPAREN
  | RPAREN
  | LBRACK
  | RBRACK
  | LBRACE
  | RBRACE
  | COMMA
  | DOT
  | EQUALS
  | PLUS
  | MULTIPLY

  | SHADER_KEYWORD
  | PROPERTIES_KEYWORD
  | SUB_SHADER_KEYWORD
  | FALLBACK_KEYWORD
  | CUSTOM_EDITOR_KEYWORD

  | COLOR_KEYWORD
  | CUBE_KEYWORD
  | FLOAT_KEYWORD
  | INT_KEYWORD
  | RANGE_KEYWORD
  | TEXTURE_2D_KEYWORD
  | TEXTURE_3D_KEYWORD
  | VECTOR_KEYWORD

  | BAD_CHARACTER
;

abstract errorElementWithoutRBrace
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
:
  IDENTIFIER?

  | CG_PROGRAM
  | CG_INCLUDE
  | CG_END

  | LPAREN
  | RPAREN
  | LBRACK
  | RBRACK
  | LBRACE
  | COMMA
  | DOT
  | EQUALS
  | PLUS
  | MULTIPLY

  | SHADER_KEYWORD
  | PROPERTIES_KEYWORD
  | SUB_SHADER_KEYWORD
  | FALLBACK_KEYWORD
  | CUSTOM_EDITOR_KEYWORD

  | COLOR_KEYWORD
  | CUBE_KEYWORD
  | FLOAT_KEYWORD
  | INT_KEYWORD
  | RANGE_KEYWORD
  | TEXTURE_2D_KEYWORD
  | TEXTURE_3D_KEYWORD
  | VECTOR_KEYWORD

  | BAD_CHARACTER
;

// Making command names their own tokens makes it easier to parse (especially
// with regard to follow tokens and error messages), but makes it trickier to
// parse actually identifiers, such as property names. This nonterminal matches
// the IDENTIFIER token, as well as all of the keywords
//
// Option 1. Call this `identifier`. This generates `IIdentifier` as a partial interface. Add another
//   implementation and derive it from `Psi.Tree.IIdentifier`. We need to use `customImpl` so we can add
//   a derived instance that will implement `IIdentifier.Name`
// Option 2. Call this `shaderLabIdentifier` to distinguish with the `IDENTIFIER` token. All else as
//   above. Downside is that this is a composite element (big deal?)
// Option 3. Create an abstract nonterminal, which then requires a `ParseIdentifier` method. This would
//   check the current token is either `IDENTIFIER` or belongs to the Keywords set. Then can return any
//   element, e.g. `IDENTIFER` as a token, not a composite
// Option 4. As above, but create another private non terminal that 
//
// Note that C# does context sensitive keywords the other way - all context sensitive keywords are identifiers
// and parsed via custom match/expect methods. This has implications on follow tokens (on error, can skip to
// any following identifier, rather than expected keyword)
shaderLabIdentifier
options {
  customImpl;
}
:
  IDENTIFIER

  | SHADER_KEYWORD
  | PROPERTIES_KEYWORD
  | SUB_SHADER_KEYWORD
  | FALLBACK_KEYWORD
  | CUSTOM_EDITOR_KEYWORD

  | COLOR_KEYWORD
  | CUBE_KEYWORD
  | FLOAT_KEYWORD
  | INT_KEYWORD
  | RANGE_KEYWORD
  | TEXTURE_2D_KEYWORD
  | TEXTURE_3D_KEYWORD
  | VECTOR_KEYWORD

  | OFF_KEYWORD
;

errorhandling shaderLabFile options { stubBase="ShaderLabFileElement"; }
:
  shaderCommand<SHADER_LAB_COMMAND, Command>
;

shaderCommand
:
  SHADER_KEYWORD<SHADER_LAB_KEYWORD, ShaderKeyword>
  shaderValue<SHADER_LAB_VALUE, Value>
;

// TODO: Where are CGINCLUDE blocks valid?
// I've seen them after Properties, before Shader and after Tags...
// TODO: Add Dependency property (from default shader)
// https://forum.unity3d.com/threads/shaderlab-dependency-property.215130/
// https://forum.unity3d.com/threads/solved-pass-data-from-a-shader-to-its-dependency-shader-or-set-dependecy-shader-data.437961/
// https://alastaira.wordpress.com/2013/12/07/custom-unity-terrain-material-shaders/
// e.g. Dependency "AddPassShader" = "Custom/ToonTerrainAddPass"
// Looks like first string literal is a known value, called by the terrain shader
shaderValue
:
  STRING_LITERAL<SHADER_LAB_NAME, Name>
  LBRACE<LBRACE, LBrace>
  propertiesCommand<PROPERTIES_COMMAND, PropertiesCommand>?
  // SubShaders/Category
  // I think fallback, customEditor and dependency can be in any 
  // Accept multiple instances then add inspection to only allow one?
  fallbackCommand<FALLBACK_COMMAND, FallbackCommand>?
  customEditorCommand<CUSTOM_EDITOR_COMMAND, CustomEditorCommand>?
  // dependency<DEPENDENCY_COMMAND, Dependencies>*
  RBRACE<RBRACE, RBrace>
;

// Parsing context so nested errors will resync on following rules
// Must also be errorhandling, or else no-one will check IsInFollow
errorhandling propertiesCommand
options {
  parsingContext;
}
:
  PROPERTIES_KEYWORD<SHADER_LAB_KEYWORD, PropertiesKeyword>
  propertiesValue<SHADER_LAB_VALUE, Value>
;

propertiesValue
:
  LBRACE<LBRACE, LBrace>
  propertyDeclaration<PROPERTY_DECLARATIONS, Declarations>*
  RBRACE<RBRACE, RBrace>
;

propertyDeclaration
:
  propertyHeader
  EQUALS<EQUALS, Equals>
  propertyValue<PROPERTY_VALUE, PropertValue>
;

// Error handling, to make propertyDeclaration::EQUALS a resync point
// parsing context so that a missing RPAREN in propertyType/propertyParams doesn't overflow to end of file
private errorhandling propertyHeader
options {
  parsingContext;
}
:
  attribute<ATTRIBUTE, Attributes>*
  propertyName
  propertyParameters
;

private propertyName
:
  shaderLabIdentifier<SHADER_LAB_IDENTIFIER, Name>
  | errorElementWithoutRBrace
;

private propertyParameters
:
  LPAREN<LPAREN, LParen>
  STRING_LITERAL<SHADER_LAB_NAME, DisplayName>
  COMMA<COMMA, Comma>
  propertyType<PROPERTY_TYPE, PropertyType>
  RPAREN<RPAREN, RParen>
;

interface propertyType
:
  simplePropertyType
  | rangePropertyType
;

simplePropertyType
:
  COLOR_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | CUBE_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | FLOAT_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | INT_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | TEXTURE_2D_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | TEXTURE_3D_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  | VECTOR_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
;

// Errorhandling to allow resync on RPAREN in propertyParameters
errorhandling rangePropertyType
:
  RANGE_KEYWORD<SHADER_LAB_KEYWORD, Keyword>
  LPAREN<LPAREN, LParen>
  NUMERIC_LITERAL<MIN, Min>
  COMMA<COMMA, Comma>
  NUMERIC_LITERAL<MAX, Max>
  RPAREN<RPAREN, RParen>
;

interface propertyValue
:
  scalarPropertyValue
  | vectorPropertyValue
  | texturePropertyValue
  | errorPropertyValue
;

scalarPropertyValue
:
  NUMERIC_LITERAL<SHADER_LAB_VALUE, Number>
;

vectorPropertyValue
:
  LPAREN<LPAREN, LParen>
  vectorPropertyValues
  RPAREN<RPAREN, RParen>
;

// Private and error handling to allow resync on vectorPropertyValue::RPAREN
private errorhandling vectorPropertyValues
:
  NUMERIC_LITERAL<NUMBER, Numbers>
  COMMA<COMMA, Comma>
  NUMERIC_LITERAL<NUMBER, Numbers>
  COMMA<COMMA, Comma>
  NUMERIC_LITERAL<NUMBER, Numbers>
  COMMA<COMMA, Comma>
  NUMERIC_LITERAL<NUMBER, Numbers>
;

texturePropertyValue
:
  STRING_LITERAL<SHADER_LAB_NAME, Name>
  (
    (
      LBRACE<LBRACE, LBrace>
      errorTexturePropertyBlockValues
      RBRACE<RBRACE, RBrace>
    )
    | errorPropertyValue
  )
;

// The spec says there shouldn't be anything here. Use a custom parse function to eat 
// everything up to RBRACE
private abstract errorTexturePropertyBlockValues
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
:
  errorElementWithoutRBrace*
;

abstract errorPropertyValue
options {
  interfaceName = "JetBrains.ReSharper.Psi.Tree.IErrorElement";
  elementType="ERROR_ELEMENT";
}
:
  errorElementWithoutRBrace*
;

attribute
:
  LBRACK<LBRACK, LBrack>
  shaderLabIdentifier<SHADER_LAB_IDENTIFIER, Identifier>
  attributeParameters<PARAMETERS, Parameters>?
  RBRACK<RBRACK, RBrack>
;

attributeParameters
:
  LPAREN<LPAREN, LParen>
  attributeParameterValues<PARAMETER_VALUES, ParameterValues>
  RPAREN<RPAREN, RParen>
;

attributeParameterValues
:
  attributeParameterValue<SHADER_LAB_VALUE, Value>
  (
    COMMA<COMMA, Comma>
    attributeParameterValue<SHADER_LAB_VALUE, Value>
  )*
;

// Number, unquoted(!) string literal, fully qualified type name, comma separated list of number/space containing identifiers
interface attributeParameterValue
:
  numberAttributeParameterValue
  |
    (
      // Parse the common shaderLabIdentifier, then pass it through to the rule
      // This allows switching on the next token - DOT for qualifiedAttributeParameterValue
      // or shaderLabIdentifier for stringAttributeParameterValue
      !(#id:shaderLabIdentifier)
      (
        qualifiedAttributeParameterValue[id]
        | stringAttributeParameterValue[id]
      )
    )
;

numberAttributeParameterValue
:
  NUMERIC_LITERAL<SHADER_LAB_VALUE, Value>
;

qualifiedAttributeParameterValue[shaderLabIdentifier id]
:
  &id<SHADER_LAB_IDENTIFIER, Identifiers>
  (
    DOT<DOT, Dots>
    shaderLabIdentifier<SHADER_LAB_IDENTIFIER, Identifiers>
  )+
;

// TODO: Perhaps a custom interface to allow retrieving exact text?
stringAttributeParameterValue[shaderLabIdentifier id]
:
  // One or more, separated by whitespace
  &id<SHADER_LAB_IDENTIFIER, Identifiers>
  shaderLabIdentifier<SHADER_LAB_IDENTIFIER, Identifiers>*
;

// TODO: Verify error handling
fallbackCommand
:
  FALLBACK_KEYWORD<SHADER_LAB_KEYWORD, FallbackKeyword>
  fallbackValue<SHADER_LAB_VALUE, Value>
;

fallbackValue
:
  STRING_LITERAL<SHADER_LAB_NAME, Name>
  | OFF_KEYWORD<SHADER_LAB_KEYWORD, OffKeyword>
  | errorElementWithoutRBrace   // TODO: Will this match `CustomEditor`?
;

customEditorCommand
:
  CUSTOM_EDITOR_KEYWORD<SHADER_LAB_KEYWORD, CustomEditorKeyword>
  customEditorValue<SHADER_LAB_VALUE, Value>
;

customEditorValue
:
  STRING_LITERAL<SHADER_LAB_NAME, Name>
  | errorElementWithoutRBrace
;