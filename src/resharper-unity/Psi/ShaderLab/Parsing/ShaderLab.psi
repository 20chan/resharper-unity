options{

  // Parser options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Parser class name and namespace
  parserPackage="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Gen";
  parserClassName="ShaderLabParserGenerated";

  // Strongly type the lexer we're using. ILexer<int> is the caching lexer instance
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";

  // FQN of (non-generated) class that provides messages for the parser
  parserMessagesClass="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Parsing.ParserMessages";

  // Parser, error messages + token bitsets target folder
  parserTargetSubdir="Parsing/ShaderLab";

  // Don't generate a bitset unless there's 4 or more comparisons to be made
  tokenBitsetThreshold=4;


  // Composite node type/element generation options
  // -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

  // Existing language specific ITreeNode
  "psiElementClassFQName"="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree.IShaderLabTreeNode";

  // Existing token type containing class + namespace
  tokenTypePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Parsing";
  tokenTypeClassName="ShaderLabTokenType";

  // Set base index for generated (element, not token) node types. Defaults to 2000, tokens default to 1000
  // tokenTypeBaseIndex=2000;

  // Tree node interface namespace + target folder (also target folder for navigators + visitors)
  psiInterfacePackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree";
  psiInterfacesTargetSubdir="Psi/ShaderLab/Tree";

  // Tree node implementation namespace, base type and target folder
  psiStubsPackageName="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree.Impl";
  psiStubsBaseClass="ShaderLabCompositeElement";
  psiStubsTargetSubdir="Psi/ShaderLab/Tree/Impl";

  // Existing composite node type base class
  elementTypeBaseClass="ShaderLabCompositeNodeType";

  // Namespace for generating custom interface when `customInterface` option used
  customInterfacePackage="JetBrains.ReSharper.Plugins.Unity.Psi.ShaderLab.Tree";

  // Any role used in this file that begins with this prefix must be defined in `ChildRole`
  publicChildRolePrefix="SHADER_LAB_";


  // Not sure yet...
  customImplPackage="JetBrains.ReSharper.Psi.RegExp.JsRegex.Impl.Tree";


  // Required on. Changes behaviour of various things, e.g. public child role values based on prefix
  disableReflection;
}

// Modifiers:
//
// `errorhandling` - includes following tokens in error handling. Checks next token is
//   valid following token. Generates virtual HandleErrorInXXX method that will skip to
//   the next valid following token. All tokens in between are added to the current error.
// `noerrorhandling` - same as omitting `errorhandling`
// `private`
// `abstract`
// `interface`
//
// options:
//
// `customInterface` - generate element tree node with a custom interface. Name is the same
//   as would be generated, but uses `customInterfacePackage` for namespace

errorhandling shaderLabFile options { stubBase="ShaderLabFileElement"; }
:
  shaderLabCommand<SHADER_LAB_COMMAND, Command>
;

errorhandling shaderLabCommand options {}
:
  IDENTIFIER `ShaderLabCommand <SHADER_LAB_IDENTIFIER, Identifier>
  shaderLabValue<SHADER_LAB_VALUE, Value>
;

errorhandling shaderLabValue options {}
:
  STRING_LITERAL<SHADER_LAB_NAME, Name>
  LBRACE<SHADER_LAB_LBRACE, LBrace>
  // TODO: Do these have a strict order?
  propertiesCommand<PROPERTIES_COMMAND, PropertiesCommand>?
//  fallbackCommand<FALLBACK_COMMAND, FallbackCommand>?
//  customEditorComamnd<CUSTOM_EDITOR_COMMAND, CustomEditorCommand>?
  RBRACE<SHADER_LAB_RBRACE, RBrace>
;

errorhandling propertiesCommand options {}
:
  IDENTIFIER `PropertiesCommand <SHADER_LAB_IDENTIFIER, Identifier>
  propertiesValue<SHADER_LAB_VALUE, Value>
;

errorhandling propertiesValue options {}
:
  LBRACE<SHADER_LAB_LBRACE, LBrace>
  RBRACE<SHADER_LAB_RBRACE, RBrace>
;